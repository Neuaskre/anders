module algebra where
import lib/foundations/mltt/sigma
import lib/foundations/univalent/path

def isComm   (M : U) (op : M -> M -> M) : U := Œ† (x y : M), Path M (op x y) (op y x)
def isAssoc  (M : U) (op : M -> M -> M) : U := Œ† (a b c : M), Path M (op a (op b c)) (op (op a b) c)
def hasLId   (M : U) (op : M -> M -> M) (id : M) : U := Œ† (x : M), Path M (op id x) x
def hasRId   (M : U) (op : M -> M -> M) (id : M) : U := Œ† (x : M), Path M (op x id) x
def hasId    (M : U) (op : M -> M -> M) (id : M) : U := Œ£ (_ : hasLId M op id), hasRId M op id
def hasLInv  (G : U) (op : G -> G -> G) (id : G) (inv : G -> G) : U := Œ† (x : G), Path G (op (inv x) x) id
def hasRInv  (G : U) (op : G -> G -> G) (id : G) (inv : G -> G) : U := Œ† (x : G), Path G (op x (inv x)) id
def hasInv   (G : U) (op : G -> G -> G) (id : G) (inv : G -> G) : U := Œ£ (_ : hasLInv G op id inv), hasRInv G op id inv
def isLDistr (R : U) (ad : R -> R -> R) (mu : R -> R -> R) : U := Œ† (a b c: R), Path R (mu a (ad b c)) (ad (mu a b) (mu a c))
def isRDistr (R : U) (ad : R -> R -> R) (mu : R -> R -> R) : U := Œ† (a b c: R), Path R (mu (ad b c) a) (ad (mu b a) (mu c a))
def isDistr  (R : U) (ad : R -> R -> R) (mu : R -> R -> R) : U := Œ£ (_ : isLDistr R ad mu), isRDistr R ad mu

def isMonoid    (M : SET) : U := Œ£ (o: M.1 -> M.1 -> M.1) (a: isAssoc M.1 o) (id: M.1), hasId M.1 o id
def isGroup     (G : SET) : U := Œ£ (m: isMonoid G) (inv: G.1 -> G.1), hasInv G.1 m.1 m.2.2.1 inv
def isDiffGroup (G : SET) : U := Œ£ (g: isGroup G) (c: isComm G.1 g.1.1) (b: G.1 -> G.1), Œ† (x : G.1), Path G.1 (b (b x)) g.1.2.2.1
def isCMonoid   (M : SET) : U := Œ£ (m: isMonoid M), isComm M.1 m.1
def isAbGroup   (G : SET) : U := Œ£ (g: isGroup G), isComm G.1 g.1.1
def isRing      (R : SET) : U := Œ£ (m: isMonoid R) (a: isAbGroup R), isDistr R.1 a.1.1.1 m.1
def isAbRing    (R : SET) : U := Œ£ (m: isCMonoid R) (a: isAbGroup R), isDistr R.1 a.1.1.1 m.1.1

def monoid  : U‚ÇÅ := Œ£ (X : SET), isMonoid X
def cmonoid : U‚ÇÅ := Œ£ (X : SET), isCMonoid X
def group   : U‚ÇÅ := Œ£ (X : SET), isGroup X
def abgroup : U‚ÇÅ := Œ£ (X : SET), isAbGroup X
def ring    : U‚ÇÅ := Œ£ (X : SET), isRing X
def abring  : U‚ÇÅ := Œ£ (X : SET), isAbRing X
def dgroup  : U‚ÇÅ := Œ£ (X : SET), isDiffGroup X

-- https://arxiv.org/pdf/2302.01834.pdf

def unital   (C R: U): U := R ‚Üí (C ‚Üí R)
def counital (C R: U): U := (C ‚Üí R) ‚Üí R
def BiAlg    (C R: U): U := Œ£ (u: unital C R) (œµ: counital C R), ùüè
def Tensor   (C R: U): U := prod (BiAlg C R) (BiAlg C R)
def HopfAlg  (C R F: U): U :=
  Œ£ (‚äó: Œ† (x y: BiAlg C R), Tensor C R)
    (unit-u: F ‚Üí BiAlg C R)
    (counit-œµ: BiAlg C R ‚Üí F)
    (product-m:   Œ† (x y: BiAlg C R), Tensor C R ‚Üí BiAlg C R)
    (coproduct-Œî: Œ† (x y: BiAlg C R), BiAlg C R  ‚Üí Tensor C R)
    (antipode-S: BiAlg C R ‚Üí BiAlg C R), ùüè

def aid (C R F: U) (H: HopfAlg C R F) (x: BiAlg C R): BiAlg C R
 := H.antipode-S (H.antipode-S x)

def gconv (C R F: U) (H: HopfAlg C R F) (f g: BiAlg C R): Tensor C R
 := H.coproduct-Œî f g (H.product-m f g (H.‚äó f g))

def Dirac-Œ¥ (C R F: U) (H: HopfAlg C R F) (x: BiAlg C R): Tensor C R
 := gconv C R F H x (H.unit-u (H.counit-œµ x))

def Hopf-coherence (C R F: U) (H: HopfAlg C R F) (x: BiAlg C R)
 := Path (Tensor C R) (gconv C R F H (aid C R F H x) (H.antipode-S x))
                      (Dirac-Œ¥ C R F H x)
