include ../../../header

html
    head
        meta(property='og:title'       content='SIGMA')
        meta(property='og:description' content='Dependent Sum')
        meta(property='og:url'         content='https://anders.groupoid.space/foundations/mltt/sigma/')

block title
    title SIGMA

block content
    nav
        <a href='https://anders.groupoid.space/'>ANDERS</a>
        <a href='https://anders.groupoid.space/lib/'>LIB</a>
        <a href='#'>SIGMA</a>
    article.main
        .exe
            section
                h1 CONTEXTUAL SPACES
        aside
            time Published: 14 OCT 2017
        .exe
            section
                +tex.
                    $\Sigma$-type is a space that contains dependent pairs
                    where type of the second element depends on the value
                    of the first element. As only one point of fiber domain
                    present in every defined pair, $\Sigma$-type is also a dependent sum,
                    where fiber base is a disjoint union.

            section
                h2 Formation

                +tex.
                    $\mathbf{Definition}$ ($\Sigma$-Formation, Dependent Sum). The dependent sum
                    type is indexed over type $A$ in the sense of coproduct or disjoint union,
                    where only one fiber codomain $B(x)$ is present in pair.

                +code.
                    def Sigma (A: U) (B: A → U) : U := Σ (x: A), B(x)
                br

                +tex(true).
                    $$
                        \Sigma (A,B) =_{def} \sum_{x:A} B(x) : \mathcal{U}.
                    $$

                h2 Introduction

                +tex.
                    $\mathbf{Definition}$ (Dependent Pair). The dependent pair
                    constructor is a way to create indexed pair over type $A$
                    in the sense of coproduct or disjoint union.

                +code.
                    def pair (A: U) (B: A → U) (a: A) (b: B a) : Sigma A B := (a, b)
                br

                +tex(true).
                    $$
                        (a,b) =_{def} \prod_{A:U}\prod_{B:A \rightarrow U}\prod_{a:A}\prod_{b:B(a)} (a,b) : \sum_{x: A} B(x).
                    $$

                h2 Elimination

                +tex.
                    $\mathbf{Definition}$ (Dependent Projections). The dependent projections
                    $pr_{1}: \Sigma(A,B) \rightarrow A$ and
                    $pr_{2}: \Pi_{x: \Sigma(A,B)} B(pr_{1}(x))$ are pair deconstructors.

                +code.
                    def pr₁ (A: U) (B: A → U) (x: Sigma A B) : A ≔ x.1

                +tex(true).
                    $$
                        pr_1 : \prod_{A:U} \prod_{B:A \rightarrow U} \prod_{x: \Sigma(A,B)} A
                    $$
                +tex(true).
                    $$
                             =_{def} .1 =_{def} (a,b) \mapsto a.
                    $$

                +code.
                    def pr₂ (A: U) (B: A → U) (x: Sigma A B) : B (pr₁ A B x) ≔ x.2

                +tex(true).
                    $$
                        pr_2 : \prod_{A:U} \prod_{B:A \rightarrow U} \prod_{x: \Sigma(A,B)} B(x.1)
                    $$
                +tex(true).
                    $$
                             =_{def} .2 =_{def} (a,b) \mapsto b.
                    $$

                +tex.
                    If you want to access deep sigma a series of $.2$
                    accessors should be applied followed by $.1$.

                h2 Induction Principle

                p.
                    Dependent Elimination Principle states that
                    if predicate holds for two projections
                    then predicate holds for total space.

                +code.
                    sigInd (A: U) (B: A -> U)
                           (C: Sigma A B -> U)
                           (g: (a: A) (b: B a) -> C (a, b))
                           (p: Sigma A B): C p
                         = g p.1 p.2
                br

                h2 Computation

                +code.
                    Beta1 (A: U) (B: A -> U)
                          (a:A) (b: B a)
                        : Equ A a (pr1 A B (a,b))
                        = refl A a

                    Beta2 (A: U) (B: A -> U)
                          (a: A) (b: B a)
                        : Equ (B a) b (pr2 A B (a,b))
                        = reflect (B a)
                br

                h2 Uniqueness

                +code.
                    Eta12 (A: U) (B: A -> U) (p: Sigma A B)
                        : Equ (Sigma A B) p (pr1 A B p,pr2 A B p)
                        = refl (Sigma A B) p
                br

                h2 Theorems
                +tex.
                    $\mathbf{Theorem}$ (Axiom of Choice). If for all $x : A$ there is $y : B$
                    such that $R(x,y)$, then there is a function $f : A \rightarrow B$ such
                    that for all $x : A$ there is a witness of $R(x,f(x))$.

                +code.
                      ac (A B: U) (R: A -> B -> U):
                         (p: (x:A)->(y:B)*(R x y)) -> (f:A->B)*((x:A)->R(x)(f x))
                      = \(g: (x:A)->(y:B)*(R x y)) -> (\(i:A)->(g i).1,\(j:A)->(g j).2)

                +tex.
                    $\mathbf{Theorem}$ (Total). If fiber over base implies another fiber
                    over the same base then we can construct total space of section
                    over that base with another fiber.

                +code.
                    total (A:U) (B C: A -> U)
                          (f: (x:A) -> B x -> C x) (w: Sigma A B)
                        : Sigma A C = (w.1,f (w.1) (w.2))

                +tex.
                    $\mathbf{Theorem}$ (Path Between Sigmas). Path between
                    two sigmas $t,u: \Sigma(A,B)$ could be decomposed to
                    sigma of two paths $p:t_1=_{A}u_1)$ and $(t_2=_{B(p@i)}u_2)$.

                +code.
                    pathSig (A:U) (B : A -> U)
                            (t u : Sigma A B) :
                            Path U
                                 (Path (Sigma A B) t u)
                                 ( (p : Path A t.1 u.1)
                                 * PathP (&lt;i&gt; B (p @ i))
                                         t.2
                                         u.2)

                +tex.
                    $\mathbf{Theorem}$ (Propositions). If codomain $B: A \rightarrow U$
                    of dependent the function $f: (x:A) \rightarrow B(x)$
                    is a mere proposition and for two sigmas $t,u: \Sigma(A,B)$ there is
                    a path $\mathrm{Path}_A(t_1,u_1)$ then the path between second components $\mathrm{Path}_{B(p@i)}(t_2,u_2)$
                    is a mere proposition too. Same if codomain is set.

                +code.
                    corSigProp (A:U) (B:A-> U)
                        (pB: (x:A) -> isProp (B x))
                        (t u: Sigma A B) (p:Path A t.1 u.1):
                        isProp (PathP (&lt;i&gt;B (p@i)) t.2 u.2)

                    corSigSet (A:U) (B:A-> U)
                        (sB: (x:A) -> isSet (B x))
                        (t u: Sigma A B) (p: Path A t.1 u.1):
                        isProp (PathP (&lt;i&gt;B (p@i)) t.2 u.2)

                +tex.
                    $\mathbf{Theorem}$ (Contractability). If first and second component of sigma
                    are contractible then the total space of sigma is contractible.

                +code.
                    sigmaIsContr (A: U) (B: A -> U) (u: isContr A)
                                 (q: (x: A) -> isContr (B x))
                               : isContr (Sigma A B)

include ../../../footer
